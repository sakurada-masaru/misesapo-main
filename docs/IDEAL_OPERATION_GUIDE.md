# 単一サイト・ロールベース方式の理想的な運用方法

## 📋 概要

現在の「単一サイト・ロールベース方式」を、メールアドレスベースの認証へ移行することを前提に、理想的な運用方法を提案します。

---

## 🎯 現状のロール構成

### 現在のロール
1. **customer（ユーザー・顧客）** - 個人・法人の顧客
2. **staff（清掃員）** - 清掃作業を行うスタッフ
3. **sales（営業マン・コンシェルジュ）** - 営業担当者
4. **admin（管理者）** - システム管理者
5. **developer（開発者）** - 技術者・開発者
6. **master（マスター）** - 最上位権限

### 現状の認証方式
- **ロール選択 + パスワード**による認証
- メールアドレスは任意入力（認証には使用されない）
- クライアントサイドのみの認証

---

## 🚀 理想的な運用方法（段階的移行）

### フェーズ1: 現状維持 + 準備（現在〜短期）

#### 1.1 データ構造の準備

**ユーザーデータの設計**
```json
{
  "id": 1,
  "email": "user@example.com",
  "password_hash": "$2b$10$...",  // bcrypt等でハッシュ化
  "role": "customer",
  "name": "山田太郎",
  "company_id": null,  // 法人顧客の場合
  "status": "active",  // active, inactive, suspended
  "created_at": "2025-01-01T00:00:00Z",
  "updated_at": "2025-01-01T00:00:00Z",
  "last_login_at": null,
  "metadata": {
    "phone": "090-1234-5678",
    "address": "..."
  }
}
```

**ロールマッピングテーブル（メールドメイン別）**
```json
{
  "email_domains": {
    "@misesapo.com": ["admin", "developer", "sales"],
    "@staff.misesapo.com": ["staff"],
    "@customer.example.com": ["customer"]
  },
  "individual_mappings": {
    "specific@example.com": "admin"
  }
}
```

#### 1.2 認証フローの設計

**メールアドレスベース認証の流れ**
1. メールアドレス + パスワードでログイン
2. メールアドレスからロールを自動判定
3. ロールに応じたダッシュボードへリダイレクト

**ロール判定ロジック**
```javascript
function determineRoleFromEmail(email) {
  // 1. 個別マッピングをチェック
  if (individualMappings[email]) {
    return individualMappings[email];
  }
  
  // 2. ドメインベースのマッピングをチェック
  const domain = email.split('@')[1];
  const domainRoles = emailDomains[`@${domain}`];
  if (domainRoles && domainRoles.length > 0) {
    return domainRoles[0]; // 最初のロールを返す（複数ロール対応は後述）
  }
  
  // 3. デフォルトは顧客
  return 'customer';
}
```

#### 1.3 ログイン画面の改善

**現状**: ロール選択 + パスワード
**移行後**: メールアドレス + パスワード（ロール選択不要）

**移行期間の対応**
- 段階的移行: メールアドレス入力時は自動判定、未入力時は従来方式
- 両方の方式をサポート（後方互換性）

---

### フェーズ2: メールアドレスベース認証の実装（中期）

#### 2.1 バックエンド実装

**必要な機能**
1. **ユーザー管理API**
   - ユーザー登録・更新・削除
   - パスワードリセット
   - ロール変更

2. **認証API**
   - ログイン（メール + パスワード）
   - ログアウト
   - セッション管理
   - トークン発行（JWT推奨）

3. **ロール管理API**
   - ロール一覧取得
   - ロール変更
   - アクセス権限チェック

**推奨技術スタック**
- **認証**: JWT（JSON Web Token）
- **パスワードハッシュ**: bcrypt（Node.js）または argon2
- **セッション管理**: Redis（オプション、スケール時）
- **データベース**: PostgreSQL / MySQL

#### 2.2 フロントエンド実装

**認証フローの変更**
```javascript
// 旧: ロール選択 + パスワード
function login(role, password, email) { ... }

// 新: メールアドレス + パスワード
async function login(email, password) {
  // 1. バックエンドAPIで認証
  const response = await fetch('/api/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password })
  });
  
  // 2. レスポンスからロールを取得
  const { token, user } = await response.json();
  
  // 3. トークンを保存
  sessionStorage.setItem('auth_token', token);
  sessionStorage.setItem('user', JSON.stringify(user));
  
  // 4. ロールに応じたページへリダイレクト
  const defaultPage = getDefaultPageForRole(user.role);
  window.location.href = defaultPage;
}
```

**ロール判定の自動化**
- メールアドレスから自動的にロールを判定
- ユーザーはロールを選択する必要がない
- 複数ロールを持つ場合の対応（後述）

---

### フェーズ3: 高度な機能の実装（長期）

#### 3.1 複数ロール対応

**ユーザーが複数のロールを持つ場合**
- 例: 営業マンが顧客としても登録されている
- 例: 管理者が開発者としても登録されている

**実装方法**
```javascript
// ユーザーデータに複数ロールを保存
{
  "id": 1,
  "email": "user@example.com",
  "roles": ["customer", "staff"],  // 複数ロール
  "primary_role": "customer",  // デフォルトロール
  "role_switching_enabled": true
}

// ロール切り替え機能
function switchRole(newRole) {
  if (user.roles.includes(newRole)) {
    updateSession({ role: newRole });
    window.location.reload();
  }
}
```

**UI実装**
- ヘッダーにロール切り替えドロップダウンを表示
- 現在のロールを表示
- 切り替え可能なロールを一覧表示

#### 3.2 組織・グループ管理

**法人顧客の管理**
```json
{
  "company": {
    "id": 1,
    "name": "株式会社サンプル",
    "domain": "@sample.co.jp",
    "users": [
      { "id": 1, "email": "user1@sample.co.jp", "role": "customer" },
      { "id": 2, "email": "user2@sample.co.jp", "role": "customer" }
    ],
    "admin_user_id": 1  // 組織管理者
  }
}
```

**組織管理者の権限**
- 組織内のユーザー管理
- 組織内のデータ閲覧
- 組織設定の変更

#### 3.3 アクセスログ・監査機能

**ログ記録項目**
- ログイン・ログアウト時刻
- アクセスしたページ
- 実行した操作（CRUD）
- IPアドレス
- ユーザーエージェント

**監査ログの保存**
```json
{
  "id": 1,
  "user_id": 1,
  "action": "login",
  "resource": "/admin/users",
  "ip_address": "192.168.1.1",
  "user_agent": "Mozilla/5.0...",
  "timestamp": "2025-01-01T12:00:00Z"
}
```

---

## 📊 運用フロー

### ユーザー登録フロー

#### 顧客（customer）の登録
1. **新規登録ページ** (`/signup.html`) で登録
2. メールアドレス + パスワードを入力
3. メールアドレス確認（メール送信）
4. 確認後、自動的に `customer` ロールで登録
5. ログインページへリダイレクト

#### 清掃員（staff）の登録
1. **管理者が登録** (`/admin/users/staff/new.html`)
2. メールアドレス + 初期パスワードを設定
3. メールで初期パスワードを通知
4. 初回ログイン時にパスワード変更を促す

#### 営業マン（sales）の登録
1. **管理者が登録** (`/admin/users/sales/new.html`)
2. メールアドレス + 初期パスワードを設定
3. メールで初期パスワードを通知
4. 初回ログイン時にパスワード変更を促す

#### 管理者（admin）の登録
1. **マスターまたは既存管理者が登録**
2. メールアドレス + 初期パスワードを設定
3. メールで初期パスワードを通知
4. 初回ログイン時にパスワード変更を促す

### ロール管理フロー

#### ロールの変更
1. **管理者がユーザー管理画面** (`/admin/users/{id}/edit.html`) で変更
2. 変更理由を記録（監査ログ）
3. ユーザーにメール通知（オプション）
4. 次回ログイン時に新しいロールが適用

#### ロールの一時停止
1. **管理者がユーザーを一時停止**
2. `status: "suspended"` に変更
3. ログイン不可（エラーメッセージ表示）
4. 再開時に `status: "active"` に戻す

### パスワード管理フロー

#### パスワードリセット
1. **パスワードリセットページ** (`/reset-password.html`) で申請
2. メールアドレスを入力
3. リセットトークンをメール送信
4. トークンでパスワード再設定ページへアクセス
5. 新しいパスワードを設定

#### パスワード変更
1. **設定ページ** (`/mypage/settings.html`) で変更
2. 現在のパスワードを確認
3. 新しいパスワードを設定
4. 変更を保存

---

## 🔐 セキュリティ対策

### 認証関連

1. **パスワードポリシー**
   - 最低8文字以上
   - 大文字・小文字・数字を含む
   - 特殊文字を含む（推奨）
   - 過去のパスワードとの重複チェック

2. **セッション管理**
   - JWTトークンの有効期限設定（例: 8時間）
   - リフレッシュトークンの実装
   - ログアウト時のトークン無効化

3. **二要素認証（2FA）**（オプション）
   - 管理者・開発者向けに実装
   - SMSまたはアプリベースの認証

### アクセス制御

1. **サーバーサイドでの権限チェック**
   - すべてのAPIエンドポイントで権限チェック
   - ページアクセス時にもサーバーサイドでチェック

2. **レート制限**
   - ログイン試行回数の制限（5回/15分）
   - API呼び出しのレート制限

3. **IP制限**（オプション）
   - 管理画面へのアクセスを特定IPに制限
   - VPN経由でのアクセスを推奨

---

## 📈 スケーラビリティの考慮

### ユーザー数が増えた場合

1. **データベースの最適化**
   - インデックスの追加（email, role, status）
   - パーティショニング（必要に応じて）

2. **キャッシュ戦略**
   - ユーザー情報のキャッシュ（Redis）
   - ロール情報のキャッシュ

3. **読み取り専用レプリカ**
   - ユーザー情報の読み取りをレプリカに分散

### ロールが増えた場合

1. **ロール定義の外部化**
   - データベースにロール定義を保存
   - 動的なロール追加に対応

2. **権限の細分化**
   - ロールベース（RBAC）から属性ベース（ABAC）へ移行
   - より柔軟な権限管理

---

## 🛠️ 実装優先順位

### フェーズ1（必須・短期）
1. ✅ ユーザーデータ構造の設計
2. ✅ メールアドレスベース認証の設計
3. ✅ ロール判定ロジックの実装
4. ✅ ログイン画面の改善

### フェーズ2（重要・中期）
1. バックエンド認証APIの実装
2. パスワードハッシュ化の実装
3. JWTトークンの実装
4. ユーザー管理画面の実装

### フェーズ3（拡張・長期）
1. 複数ロール対応
2. 組織・グループ管理
3. アクセスログ・監査機能
4. 二要素認証（2FA）

---

## 📝 運用チェックリスト

### 日常運用

- [ ] 新規ユーザー登録の承認
- [ ] ロール変更の承認
- [ ] パスワードリセット申請の対応
- [ ] アクセスログの確認
- [ ] 異常なアクセスの監視

### 定期メンテナンス

- [ ] 非アクティブユーザーの確認（3ヶ月以上未ログイン）
- [ ] パスワードポリシーの見直し
- [ ] セキュリティアップデートの適用
- [ ] ログのアーカイブ
- [ ] バックアップの確認

### 緊急時対応

- [ ] セキュリティインシデントの対応手順
- [ ] ユーザーアカウントの緊急停止
- [ ] ロールの一括変更
- [ ] ログの緊急取得

---

## 🎯 まとめ

### 理想的な運用のポイント

1. **メールアドレスベースの認証**
   - ユーザーはロールを選択する必要がない
   - メールアドレスから自動的にロールを判定
   - 運用が簡単

2. **柔軟なロール管理**
   - 複数ロールに対応
   - ロールの動的な変更
   - 組織・グループ管理

3. **セキュリティの強化**
   - サーバーサイドでの権限チェック
   - アクセスログ・監査機能
   - パスワードポリシーの徹底

4. **運用の自動化**
   - ユーザー登録の自動化
   - ロール判定の自動化
   - 監査ログの自動記録

### 移行計画

1. **短期（1-2ヶ月）**: データ構造の準備、ロール判定ロジックの実装
2. **中期（3-6ヶ月）**: バックエンド認証APIの実装、メールアドレスベース認証への移行
3. **長期（6ヶ月以上）**: 高度な機能の実装、運用の最適化

現状のロールベース認証から、メールアドレスベース認証への移行を段階的に進めることで、運用を効率化し、セキュリティを強化できます。


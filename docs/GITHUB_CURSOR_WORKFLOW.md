# GitHub運用とCursor活用方法（MDCS準拠）

**作成日**: 2025年12月10日  
**目的**: MDCSの論理に則った、GitHubとCursorの有効な活用方法を定義

---

## 🎯 前提条件（MDCSの三段論法）

### 現在の開発環境

- **開発者**: 2名（ユーザー：全権掌握、部下：フロントエンジニア）
- **バージョン管理**: GitHub（公開リポジトリ）
- **開発ツール**: Cursor（両者が使用）
- **データ管理**: AWS（動的データ）
- **サイト公開**: GitHub Pages

### MDCSの論理に基づく原則

- **原理**: 五十音表の対照構造（あ行：主観・伝え手 ↔ わ行：客観・受け手）
- **原則**: 伝え手と受け手の概念、ニーズとシーズの関係性
- **システム運用**: 原理→原則→システム運用の階層構造

---

## 📐 GitHub運用戦略（MDCS準拠）

### 1. ブランチ戦略（あ行：主観・伝え手 ↔ わ行：客観・受け手）

**基本構造**:

```
main（本番環境・『う』：システムの存在そのもの）
  ├── develop（開発環境・『あ』：主観・伝え手）
  │   ├── feature/機能名（機能開発・『え』：選ぶ側）
  │   ├── fix/バグ修正名（バグ修正・『い』：実行する側）
  │   └── refactor/リファクタリング名（リファクタリング・『お』：蓄える側）
  └── hotfix/緊急修正名（緊急修正・『ゐ』：実行される側）
```

**ブランチの役割**:

- **main**: 本番環境（『う』：システムの存在そのもの）
  - 常にデプロイ可能な状態を保つ
  - 保護ルールを設定（直接push禁止、PR必須）

- **develop**: 開発環境（『あ』：主観・伝え手）
  - 開発中の機能を統合
  - 開発者（伝え手）が作業する環境

- **feature/**: 機能開発（『え』：選ぶ側・実践知識）
  - 新機能の開発
  - 営業マンのツール的な選択肢

- **fix/**: バグ修正（『い』：実行する側・最終決定）
  - バグ修正の実行
  - 最終決定としての修正

- **hotfix/**: 緊急修正（『ゐ』：実行される側）
  - 本番環境の緊急修正
  - 実行される側の対応

### 2. コミットメッセージ規約（Conventional Commits）

**形式**: `<type>(<scope>): <subject>`

**タイプ（MDCSの10の母音に対応）**:
- `feat`: 新機能（『え』：選ぶ側）
- `fix`: バグ修正（『い』：実行する側）
- `docs`: ドキュメント（『お』：蓄える側）
- `style`: コードスタイル（『を』：蓄えられる側）
- `refactor`: リファクタリング（『あ』：主観）
- `test`: テスト（『わ』：客観）
- `chore`: その他（『う』：共通事項）

**例**:
```
feat(sales): 見積もり作成機能を追加
fix(staff): レポート提出時のバグを修正
docs(mdcs): MDCSの論理構造をドキュメント化
```

### 3. プルリクエスト（PR）の運用

**PRの流れ（システムの流れ：う→あ→お→え→い）**:

1. **feature/fixブランチで作業**（『あ』：主観・伝え手）
   - 開発者が作業する
   - コミットを積み重ねる

2. **PRを作成**（『わ』：客観・受け手）
   - developブランチへのPR
   - レビューを依頼

3. **コードレビュー**（『あ』↔『わ』の対話）
   - 伝え手（開発者）と受け手（レビュアー）の対話
   - ニーズとシーズの調整

4. **マージ**（『い』：実行する側）
   - 最終決定としてのマージ
   - developブランチに統合

5. **デプロイ**（『ゐ』：実行される側）
   - 実行される側の対応
   - 本番環境への反映

**PRテンプレート**:

```markdown
## 概要
<!-- 変更内容の概要 -->

## 変更内容
<!-- 具体的な変更内容 -->

## 関連Issue
<!-- 関連するIssue番号 -->

## MDCS準拠チェック
- [ ] 三段論法による前提条件の検証
- [ ] 演繹法による論理的展開
- [ ] 末広がりな思想に基づく拡張
- [ ] 10の母音の分類に準拠

## チェックリスト
- [ ] コードレビューを依頼した
- [ ] テストを実行した
- [ ] ドキュメントを更新した
```

### 4. 保護ルールの設定

**mainブランチ**:
- 直接push禁止
- PR必須
- レビュー必須（1名以上）
- ステータスチェック必須

**developブランチ**:
- 直接push可能（開発者）
- PR推奨
- レビュー推奨

---

## 🎯 Cursor活用方法（MDCS準拠）

### 1. Cursorの基本設定

**推奨設定**:
- **AI Model**: 最新のモデルを使用
- **Context**: プロジェクト全体を理解させる
- **Rules**: `.cursorrules` ファイルを活用

### 2. `.cursorrules` ファイルの活用

**MDCSの論理を`.cursorrules`に記載**:

既存の`.cursorrules`ファイルを確認し、MDCSの論理を追加します。

### 3. Cursorでの作業フロー

**1. 機能開発の開始**（『あ』：主観・伝え手）

```bash
# ブランチを作成
git checkout -b feature/新機能名

# Cursorで作業
# - AIに要件を説明
# - MDCSの論理に基づいた実装を依頼
# - コード生成を依頼
# - レビューと修正
```

**2. コード生成とレビュー**（『わ』：客観・受け手）

- CursorのAIに要件を説明
- MDCSの論理に基づいた実装を依頼
- 生成されたコードをレビュー
- MDCSの論理に準拠しているか確認

**3. コミットとプッシュ**（『い』：実行する側）

```bash
# 変更をステージング
git add .

# コミット（Conventional Commits）
git commit -m "feat(scope): 機能の説明"

# プッシュ
git push origin feature/新機能名
```

**4. PRの作成とレビュー**（『あ』↔『わ』の対話）

- GitHubでPRを作成
- レビューを依頼
- フィードバックを受けて修正

**5. マージとデプロイ**（『ゐ』：実行される側）

- PRが承認されたらマージ
- 自動デプロイが実行される

### 4. Cursorの効果的な使い方

**1. コンテキストの提供**:
- プロジェクト全体の構造を理解させる
- MDCSの論理を説明
- 関連するファイルを参照

**2. 段階的な開発**:
- 小さな機能から始める
- 基盤から拡張する（末広がりな思想）
- 前提条件を確認してから進める

**3. コードレビュー**:
- 生成されたコードをレビュー
- MDCSの論理に準拠しているか確認
- 一貫性を保つ

**4. ドキュメント生成**:
- コードの説明を生成
- MDCSの論理に基づいたドキュメント
- 関係者への伝達を容易にする

### 5. チームでのCursor活用

**1. 知識の共有**:
- `.cursorrules` でMDCSの論理を共有
- 同じ前提条件で作業
- 一貫性を保つ

**2. コードレビュー**:
- Cursorで生成されたコードをレビュー
- MDCSの論理に準拠しているか確認
- 相互補完的な環境を構築

**3. 属人化の廃止**:
- MDCSの論理により、誰でも同じ判断ができる
- CursorのAIが一貫したコードを生成
- 一人がみんなをカバーし、みんなが一人をカバーする

---

## 🎯 実践的なワークフロー

### 日常的な開発フロー

**1. 作業開始**（『あ』：主観・伝え手）

```bash
# 最新のdevelopブランチを取得
git checkout develop
git pull origin develop

# 新しいfeatureブランチを作成
git checkout -b feature/機能名
```

**2. Cursorで開発**（『え』：選ぶ側・実践知識）

- Cursorで要件を説明
- MDCSの論理に基づいた実装を依頼
- AIにコード生成を依頼
- 生成されたコードをレビュー
- 必要に応じて修正

**3. コミット**（『い』：実行する側）

```bash
# 変更をステージング
git add .

# コミット（Conventional Commits）
git commit -m "feat(scope): 機能の説明"

# プッシュ
git push origin feature/機能名
```

**4. PRの作成**（『わ』：客観・受け手）

- GitHubでPRを作成
- レビューを依頼
- フィードバックを受けて修正

**5. マージとデプロイ**（『ゐ』：実行される側）

- PRが承認されたらマージ
- 自動デプロイが実行される

### 緊急時の対応（hotfix）

**1. hotfixブランチを作成**（『い』：実行する側）

```bash
# mainブランチからhotfixブランチを作成
git checkout main
git pull origin main
git checkout -b hotfix/緊急修正名
```

**2. 修正を実施**（『あ』：主観・伝え手）

- Cursorで修正内容を説明
- AIに修正コードを生成
- 修正を確認

**3. コミットとプッシュ**（『い』：実行する側）

```bash
git add .
git commit -m "fix(scope): 緊急修正の説明"
git push origin hotfix/緊急修正名
```

**4. PRの作成とマージ**（『わ』：客観・受け手）

- mainブランチへのPRを作成
- 緊急レビューを実施
- マージしてデプロイ

**5. developブランチにもマージ**（『を』：蓄えられる側）

- 同じ修正をdevelopブランチにも反映
- 履歴を保持

---

## 🎯 MDCSの論理に基づく運用原則

### 1. 伝え手と受け手の概念

**あ行（主観・伝え手）**:
- 開発者が作業する（伝え手）
- コードを書く、PRを作成する
- ニーズやシーズを持つ側

**わ行（客観・受け手）**:
- コードを受け取る（受け手）
- レビューする、マージする
- ニーズやシーズを受け取る側

### 2. システムの流れ：う→あ→お→え→い

1. **『う』（存在）**: GitHubリポジトリの存在
2. **『あ』（主観）**: 開発者の作業
3. **『お』（経験知識）**: ドキュメント、知識の蓄積
4. **『え』（選択）**: 機能の選択、実装方法の選択
5. **『い』（実行）**: コミット、マージ、デプロイ

### 3. 対比関係：うわをゑゐ

- **『う』**: GitHubリポジトリ（共通事項）
- **『わ』**: コードレビュー（受け手）
- **『を』**: ドキュメント、履歴（蓄えられる側）
- **『ゑ』**: 選択された実装（選ばれる側）
- **『ゐ』**: デプロイされたシステム（実行される側）

---

## 🎯 ベストプラクティス

### 1. コミット頻度

- **小さなコミットを頻繁に**: 1つの機能や修正ごとにコミット
- **意味のあるコミット**: 何を変更したかが明確
- **Conventional Commits**: 一貫したコミットメッセージ

### 2. ブランチの命名

- **feature/**: 新機能
- **fix/**: バグ修正
- **refactor/**: リファクタリング
- **docs/**: ドキュメント
- **hotfix/**: 緊急修正

### 3. PRのサイズ

- **小さなPR**: 1つの機能や修正に集中
- **レビューしやすい**: 変更内容が明確
- **テスト可能**: 独立してテストできる

### 4. コードレビュー

- **MDCSの論理に準拠**: 一貫性を確認
- **前提条件の確認**: 三段論法の検証
- **段階的な拡張**: 末広がりな思想の確認

### 5. ドキュメント

- **MDCSの論理を記載**: `.cursorrules` に記載
- **変更履歴を記録**: CHANGELOG.md を更新
- **関係者への伝達**: 明確な説明

---

## 🎯 トラブルシューティング

### 1. コンフリクトの解決

**原因**: 同じファイルを複数のブランチで変更

**解決方法**:
```bash
# 最新のdevelopブランチを取得
git checkout develop
git pull origin develop

# featureブランチに戻る
git checkout feature/機能名

# developブランチをマージ
git merge develop

# コンフリクトを解決
# Cursorでコンフリクトを確認
# 必要に応じてAIに解決方法を聞く

# 解決後、コミット
git add .
git commit -m "merge: developブランチをマージ"
```

### 2. 間違ったコミットの修正

**方法1: 直前のコミットを修正**

```bash
# 変更を追加
git add .

# コミットを修正
git commit --amend -m "修正後のコミットメッセージ"

# 強制プッシュ（注意：共有ブランチでは避ける）
git push --force origin feature/機能名
```

**方法2: 新しいコミットで修正**

```bash
# 修正をコミット
git commit -m "fix: 前のコミットの修正"
```

### 3. ブランチの整理

**古いブランチの削除**:

```bash
# ローカルブランチの削除
git branch -d feature/古い機能名

# リモートブランチの削除
git push origin --delete feature/古い機能名
```

---

## 🎯 Cursorでの具体的な活用例

### 1. 新機能の実装

**プロンプト例**:
```
MDCSの論理に基づいて、営業マンの見積もり作成機能を実装してください。

要件:
- 見積もり作成画面（/sales/estimates/new.html）
- 見積もり一覧画面（/sales/estimates.html）
- 見積もり詳細画面（/sales/estimates/[id].html）

MDCSの分類:
- 『え』（選ぶ側・実践知識・選択）: 営業マンのツール
- システムの流れ: う→あ→お→え→い

実装方針:
- 三段論法による前提条件の検証
- 演繹法による論理的展開
- 末広がりな思想に基づく拡張
```

### 2. バグ修正

**プロンプト例**:
```
MDCSの論理に基づいて、清掃員レポート提出時のバグを修正してください。

問題:
- レポート提出時にエラーが発生する
- 画像のアップロードが失敗する

MDCSの分類:
- 『い』（実行する側・最終決定）: 実行プログラム
- 『ゐ』（実行される側）: 実行ボタン、実行された結果

修正方針:
- 前提条件の確認（三段論法）
- 論理的な修正（演繹法）
- 影響範囲の限定（末広がりな思想）
```

### 3. リファクタリング

**プロンプト例**:
```
MDCSの論理に基づいて、コードをリファクタリングしてください。

対象:
- 社内管理システムのコード
- 重複コードの削減
- 可読性の向上

MDCSの分類:
- 『お』（蓄える側・経験知識）: 社内管理システム
- 『を』（蓄えられる側）: コード、知識の蓄積

リファクタリング方針:
- MDCSの論理に準拠した構造
- 一貫性の確保
- 段階的な改善（末広がりな思想）
```

---

## 🎯 まとめ

**GitHub運用とCursor活用の原則**:

1. **MDCSの論理に準拠**: 原理→原則→システム運用の階層構造
2. **伝え手と受け手の概念**: あ行（主観・伝え手）↔ わ行（客観・受け手）
3. **システムの流れ**: う→あ→お→え→い に従った作業
4. **対比関係**: うわをゑゐ を意識した運用
5. **一貫性の保証**: MDCSの論理により、一貫性が保証される

この運用方法により、MDCSの論理に基づいた、一貫性のある開発環境を構築できます。
